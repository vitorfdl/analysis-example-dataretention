"use strict";
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_chunk_1 = __importDefault(require("lodash.chunk"));
const BatchRequest_1 = __importDefault(require("../../common/BatchRequest"));
const sleep_1 = __importDefault(require("../../common/sleep"));
const TagoIOModule_1 = __importDefault(require("../../common/TagoIOModule"));
const dateParser_1 = __importDefault(require("../Utils/dateParser"));
class Device extends TagoIOModule_1.default {
    constructor() {
        super(...arguments);
        this.batch = new BatchRequest_1.default(this.params);
    }
    /**
     * Get information about the current device
     * @example
     * ```js
     * const myDevice = new Device({ token: "my_device_token" });
     *
     * const result = await myDevice.info();
     * ```
     */
    async info() {
        let result = await this.doRequest({
            path: "/info",
            method: "GET",
        });
        result = dateParser_1.default(result, ["created_at", "updated_at", "last_input", "last_output"]);
        return result;
    }
    /**
     * Send data to device
     * @param data An array or one object with data to be send to TagoIO using device token
     * @example
     * ```js
     * const myDevice = new Device({ token: "my_device_token" });
     *
     * const result = await myDevice.sendData({
     *   variable: "temperature",
     *   unit: "F",
     *   value: 55,
     *   time: "2015-11-03 13:44:33",
     *   location: { lat: 42.2974279, lng: -85.628292 },
     * });
     * ```
     */
    async sendData(data) {
        data = Array.isArray(data) ? data : [data];
        const result = await this.doRequest({
            path: "/data",
            method: "POST",
            body: data,
        });
        return result;
    }
    /**
     * Get data from TagoIO Device.
     * @param queryParams Object with query params
     * @returns An array of TagoIO registers
     * @example
     * ```js
     * const myDevice = new Device({ token: "my_device_token" });
     *
     * const result = await myDevice.getData({
     *   query: "last_item",
     *   variable: "humidity",
     * });
     * ```
     */
    async getData(queryParams) {
        if ((queryParams === null || queryParams === void 0 ? void 0 : queryParams.query) === "default") {
            delete queryParams.query;
        }
        let result = await this.doRequest({
            path: "/data",
            method: "GET",
            params: queryParams,
        });
        if (typeof result === "number") {
            result = [
                {
                    id: "none",
                    origin: "?",
                    time: new Date(),
                    value: result,
                    variable: "?",
                },
            ];
        }
        return result.map((item) => dateParser_1.default(item, ["time", "created_at"]));
    }
    /**
     * Delete data from device
     * @param queryParams
     * @example
     * ```js
     * const myDevice = new Device({ token: "my_device_token" });
     *
     * const result = await myDevice.deleteData({
     *   query: "last_item",
     *   variable: "humidity",
     *   value: 10
     * });
     * ```
     */
    async deleteData(queryParams) {
        if (!queryParams) {
            queryParams = { query: "last_item" };
        }
        if ((queryParams === null || queryParams === void 0 ? void 0 : queryParams.query) === "default") {
            delete queryParams.query;
        }
        const result = await this.doRequest({
            path: "/data",
            method: "DELETE",
            params: queryParams,
        });
        return result;
    }
    /**
     * Get parameters from device
     * @param onlyUnRead set true to get only unread parameters
     * @example
     * ```js
     * const myDevice = new Device({ token: "my_device_token" });
     *
     * const result = await myDevice.getParameters();
     * ```
     */
    async getParameters(onlyUnRead) {
        const params = {};
        if (onlyUnRead === true) {
            params.sent_status = true;
        }
        const result = await this.doRequest({
            path: "/device/params",
            method: "GET",
            params: params,
        });
        return result;
    }
    /**
     * Mark parameter as read
     * @param parameterID Parameter identification
     * @example
     * ```js
     * const myDevice = new Device({ token: "my_device_token" });
     *
     * const result = await myDevice.setParameterAsRead("parameter_id");
     * ```
     *
     */
    async setParameterAsRead(parameterID) {
        const result = await this.doRequest({
            path: `/device/params/${parameterID}`,
            method: "PUT",
        });
        return result;
    }
    /**
     * Get Data Streaming
     *
     * @experimental
     * @param params Data Query
     * @param options Stream options
     * @example
     * ```js
     * const myDevice = new Device({ token: "my_device_token" });
     *
     * for await (const items of myDevice.getDataStreaming()) {
     *  console.log(items);
     * }
     * ```
     */
    getDataStreaming(params, options) {
        return __asyncGenerator(this, arguments, function* getDataStreaming_1() {
            const poolingRecordQty = (options === null || options === void 0 ? void 0 : options.poolingRecordQty) || 1000;
            const poolingTime = (options === null || options === void 0 ? void 0 : options.poolingTime) || 1000; // 1 seg
            const neverStop = (options === null || options === void 0 ? void 0 : options.neverStop) || false;
            if (poolingRecordQty > 10000) {
                throw new Error("The maximum of poolingRecordQty is 10000");
            }
            const qty = Math.ceil(poolingRecordQty);
            let skip = 0;
            let stop = false;
            while (!stop) {
                yield __await(sleep_1.default(poolingTime));
                yield yield __await((async () => {
                    const data = await this.getData(Object.assign(Object.assign({}, params), { qty, skip, query: "default", ordination: "ascending" }));
                    skip += data.length;
                    if (!neverStop) {
                        stop = data.length === 0 || data.length < poolingRecordQty;
                    }
                    return data;
                })());
            }
        });
    }
    /**
     * Stream data to device
     *
     * @experimental
     * @param data An array or one object with data to be send to TagoIO using device token
     * @param options Stream options
     * @example
     * ```js
     * const myDevice = new Device({ token: "my_device_token" });
     *
     * const data = [
     *     {
     *       variable: "temperature",
     *       unit: "F",
     *       value: 55,
     *       time: "2015-11-03 13:44:33",
     *       location: { lat: 42.2974279, lng: -85.628292 },
     *     },
     *     {
     *       variable: "temperature",
     *       unit: "F",
     *       value: 53,
     *       time: "2015-11-03 13:44:33",
     *       location: { lat: 43.2974279, lng: -86.628292 },
     *     },
     *     // ...
     *   ];
     *
     *   const result = await myDevice.sendDataStreaming(data, {
     *     poolingRecordQty: 1000,
     *     poolingTime: 1000,
     *   });
     * ```
     */
    async sendDataStreaming(data, options) {
        const poolingRecordQty = (options === null || options === void 0 ? void 0 : options.poolingRecordQty) || 1000;
        const poolingTime = (options === null || options === void 0 ? void 0 : options.poolingTime) || 1000; // 1 seg
        if (!Array.isArray(data)) {
            return Promise.reject("Only data array is allowed");
        }
        const dataChunk = lodash_chunk_1.default(data, poolingRecordQty);
        for (const items of dataChunk) {
            await this.sendData(items);
            await sleep_1.default(poolingTime);
        }
        return `${data.length} Data added.`;
    }
}
exports.default = Device;
//# sourceMappingURL=Device.js.map