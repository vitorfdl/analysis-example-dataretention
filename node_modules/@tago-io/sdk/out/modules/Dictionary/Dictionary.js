"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Papa = __importStar(require("papaparse"));
const TagoIOModule_1 = __importDefault(require("../../common/TagoIOModule"));
// Regular expressions that are used for parsing the strings:
// - SPLIT is used to split the string into normal words/phrases and expressions
// - MATCH is used to extract the parts that compose an expression
const RE_SPLIT_EXPRESSION = /(#[A-Z0-9]+\.[A-Z0-9_]+(?:,(?:[^,#"]+|\"[^\"]+\")+)*#)/;
const RE_MATCH_EXPRESSION = /#([A-Z0-9]+)\.([A-Z0-9_]+(?:,(?:[^,#"]+|\"[^\"]+\")+)*)#/;
class Dictionary extends TagoIOModule_1.default {
    constructor(params) {
        super({ token: (params === null || params === void 0 ? void 0 : params.token) || "unknown", region: params === null || params === void 0 ? void 0 : params.region });
        this.language = (params === null || params === void 0 ? void 0 : params.language) || "en-US";
        this.runURL = params === null || params === void 0 ? void 0 : params.runURL;
    }
    /**
     * Get the language data for a dictionary.
     *
     * @param language Language.
     * @param dictionary ID or Slug.
     * @param runURL URL for the Run to make anonymous request.
     */
    async getLanguagesData(dictionary, language = this.language) {
        if (!language || !dictionary) {
            throw new Error("Missing parameters");
        }
        try {
            if (!this.runURL) {
                const response = await this.doRequest({
                    path: `/dictionary/${dictionary}/${language}`,
                    method: "GET",
                    cacheTTL: 3600000,
                    params: {
                        fallback: true,
                    },
                });
                return response;
            }
            else {
                const response = await TagoIOModule_1.default.doRequestAnonymous({
                    path: `/dictionary/${this.runURL}/${dictionary}/${language}`,
                    method: "GET",
                    cacheTTL: 3600000,
                });
                return response;
            }
        }
        catch (e) {
            return null;
        }
    }
    /**
     * Get value from a key in a specific dictionary for a language.
     *
     * @param language Name of the language (locale code).
     * @param dictionary Name of the dictionary.
     * @param key Name of the key.
     *
     * @example
     * ```
     * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
     * const value = dictionary.getValueFromKey("en-US", "TEST", "OK_BUTTON_LABEL");
     * ```
     */
    async getValueFromKey(language, dictionary, key) {
        if (!language || !dictionary || !key) {
            throw new Error("Missing parameters");
        }
        // Get the dictionary language data from the profile route or anonymous route (Run)
        const languagesData = await this.getLanguagesData(dictionary, language);
        // Return expression as is if the request fails or either dictionary/key do not exist
        if (!languagesData || !languagesData[key]) {
            return `#${dictionary}.${key}#`;
        }
        return languagesData[key];
    }
    /**
     * Parse an expression and extract the names of the dictionary, the key, and
     * any arguments that are passed in the expression.
     *
     * Returns `null` if the value passed is not parseable by the RegEx.
     *
     * @param expression String expression.
     *
     * @example
     * ```
     * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
     * const value = dictionary.parseExpression("#TAGORUN.WELCOME_TEXT,Hello");
     * ```
     */
    parseExpression(expression) {
        const splitExpression = expression.match(RE_MATCH_EXPRESSION);
        if (!splitExpression) {
            return null;
        }
        const dictionary = splitExpression[1];
        const keyWithParams = splitExpression[2];
        if (expression.includes(",")) {
            const { data } = Papa.parse(keyWithParams);
            const [key, ...params] = data[0];
            return { dictionary, key, params };
        }
        return { dictionary, key: keyWithParams };
    }
    /**
     * Resolve an expression in a language, replacing the parameters in the
     * dictionary value with the arguments passed in the expression.
     *
     * @param resolveParams Object with the language and the parsed expression (from `parseExpression`).
     *
     * @example
     * ```
     * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
     * const value = dictionary.resolveExpression({
     *   language: "en-US",
     *   expression: {
     *     dictionary: "TEST",
     *     key: "SOME_KEY",
     *     params: [
     *       "first parameter",
     *     ],
     *   },
     * });
     * ```
     */
    async resolveExpression(resolveParams) {
        const { language, expression } = resolveParams;
        const { dictionary, key, params } = expression;
        let resolvedString;
        // Get the dictionary value string for the expression to substitute the arguments into it
        resolvedString = await this.getValueFromKey(language, dictionary, key);
        params.forEach((substitution, index) => {
            const subRegexp = new RegExp(`\\$${index}`, "g");
            resolvedString = resolvedString.replace(subRegexp, substitution);
        });
        return resolvedString;
    }
    /**
     * Get all (and only) the expressions in a string and their parameters if applicable,
     * ignoring normal words and phrases.
     *
     * @param rawString String with words and/or expressions.
     *
     * @example
     * ```
     * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
     * const expressions = dictionary.getExpressionsFromString("Words are ignored #TEST.DICT_KEY#");
     * ```
     */
    async getExpressionsFromString(rawString) {
        const tokens = rawString.split(RE_SPLIT_EXPRESSION);
        const expressions = tokens
            .filter((token) => RE_SPLIT_EXPRESSION.test(token))
            .map((expression) => this.parseExpression(expression));
        return expressions;
    }
    /**
     * Apply the dictionary over a string, parsing the expressions in the string and
     * replacing them with the values found for the respective keys inside the dictionary
     * for a language.
     *
     * Always returns a string. Return the translated string if there are dictionary expressions,
     * the raw string with no changes if there are no expressions, and an empty string if `rawString`
     * is undefined.
     *
     * @param rawString String with words and/or expressions.
     * @param options Object containing options for the dictionary, including the language.
     *
     * @example
     * ```
     * const dictionary = new Dictionary({ language: "en-US", token: "my-token" });
     * const result = dictionary.applyToString("Words are ignored #TEST.DICT_KEY#");
     * ```
     */
    async applyToString(rawString, options) {
        const { language } = this;
        // Handling undefined strings is not this function's job
        if (!rawString || !language) {
            return rawString || "";
        }
        // Bail early if there are no variables in the string or if the value passed
        // is not a string, which can happen when not using TypeScript or passing the
        // instance to a function without the type
        if (typeof rawString !== "string" || !rawString.includes("#")) {
            return rawString;
        }
        const tokenized = rawString.split(RE_SPLIT_EXPRESSION);
        const substitutedPromises = tokenized.map((token) => {
            const isExpression = token.startsWith("#") && token.endsWith("#");
            if (isExpression) {
                const expression = this.parseExpression(token);
                if (!expression) {
                    return token;
                }
                const { dictionary, key, params } = expression;
                return params
                    ? this.resolveExpression({ language, expression })
                    : this.getValueFromKey(language, dictionary, key);
            }
            else {
                return token;
            }
        });
        let resultString;
        await Promise.all(substitutedPromises).then((resolvedValues) => {
            resultString = resolvedValues.join("");
        });
        return resultString;
    }
}
exports.default = Dictionary;
//# sourceMappingURL=Dictionary.js.map