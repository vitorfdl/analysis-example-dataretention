"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const TagoIOModule_1 = __importDefault(require("../../common/TagoIOModule"));
class Widgets extends TagoIOModule_1.default {
    /**
     * Create a Dashboard Widget
     * @param dashboardID Dashboard identification
     * @param widgetObj
     */
    async create(dashboardID, widgetObj) {
        const result = await this.doRequest({
            path: `/dashboard/${dashboardID}/widget/`,
            method: "POST",
            body: widgetObj,
        });
        return result;
    }
    /**
     * Edit the Dashboard Widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param data
     */
    async edit(dashboardID, widgetID, data) {
        const result = await this.doRequest({
            path: `/dashboard/${dashboardID}/widget/${widgetID}`,
            method: "PUT",
            body: data,
        });
        return result;
    }
    /**
     * Delete the Dashboard Widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     */
    async delete(dashboardID, widgetID) {
        const result = await this.doRequest({
            path: `/dashboard/${dashboardID}/widget/${widgetID}`,
            method: "DELETE",
        });
        return result;
    }
    /**
     * Get Info of the Dashboard Widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     */
    async info(dashboardID, widgetID) {
        const result = await this.doRequest({
            path: `/dashboard/${dashboardID}/widget/${widgetID}`,
            method: "GET",
        });
        return result;
    }
    /**
     * Get all data or resource list for the current widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param overwrite It can overwrite 'start_date', 'end_date', 'timezone' fields
     */
    async getData(dashboardID, widgetID, params) {
        const result = await this.doRequest({
            path: `/data/${dashboardID}/${widgetID}`,
            method: "GET",
            params,
        });
        return result;
    }
    /**
     * Send value of variable for the current widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param data
     * @param bypassBucket
     */
    async sendData(dashboardID, widgetID, data, bypassBucket = false) {
        const result = await this.doRequest({
            path: `/data/${dashboardID}/${widgetID}`,
            method: "POST",
            params: {
                bypass_bucket: bypassBucket,
            },
            body: data,
        });
        return result;
    }
    /**
     * Update value of variable for the current widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param data
     * @param bypassBucket
     */
    async editData(dashboardID, widgetID, data, bypassBucket = false) {
        const result = await this.doRequest({
            path: `/data/${dashboardID}/${widgetID}/data`,
            method: "PUT",
            params: {
                bypass_bucket: bypassBucket,
            },
            body: data,
        });
        return result;
    }
    /**
     * Update value of a resource for the current widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param resourceData Updated data for the resource
     * @param options Additional options
     */
    async editResource(dashboardID, widgetID, resourceData, options) {
        const result = await this.doRequest({
            path: `/data/${dashboardID}/${widgetID}/resource`,
            method: "PUT",
            params: {
                widget_exec: options === null || options === void 0 ? void 0 : options.identifier,
            },
            body: resourceData,
        });
        return result;
    }
    /**
     * Run analysis without inserting data to bucket
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param data
     */
    async runAnalysis(dashboardID, widgetID, data) {
        const result = await this.doRequest({
            path: `/data/${dashboardID}/${widgetID}/run`,
            method: "POST",
            body: data,
        });
        return result;
    }
    /**
     * Delete data by it's id, bucket and variable must be associeted with the widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param ids
     */
    async deleteData(dashboardID, widgetID, ids) {
        const result = await this.doRequest({
            path: `/data/${dashboardID}/${widgetID}`,
            method: "DELETE",
            params: {
                ids,
            },
        });
        return result;
    }
    /**
     * Generate a new token for the embed widgets
     * It can regenerate the token if call it multi-times
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     */
    async tokenGenerate(dashboardID, widgetID) {
        const result = await this.doRequest({
            path: `/dashboard/${dashboardID}/widget/${widgetID}/token`,
            method: "GET",
        });
        return result;
    }
}
exports.default = Widgets;
//# sourceMappingURL=Dashboard.Widgets.js.map