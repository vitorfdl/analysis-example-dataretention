import { Data, GenericID, GenericToken } from "../../common/common.types";
import TagoIOModule, { GenericModuleParams } from "../../common/TagoIOModule";
import { EditDataModel, EditDeviceResource, EditResourceOptions, GetDataModel, PostDataModel, WidgetInfo } from "./dashboards.types";
declare class Widgets extends TagoIOModule<GenericModuleParams> {
    /**
     * Create a Dashboard Widget
     * @param dashboardID Dashboard identification
     * @param widgetObj
     */
    create(dashboardID: GenericID, widgetObj: WidgetInfo): Promise<{
        widget: GenericID;
    }>;
    /**
     * Edit the Dashboard Widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param data
     */
    edit(dashboardID: GenericID, widgetID: GenericID, data: Partial<WidgetInfo>): Promise<string>;
    /**
     * Delete the Dashboard Widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     */
    delete(dashboardID: GenericID, widgetID: GenericID): Promise<string>;
    /**
     * Get Info of the Dashboard Widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     */
    info(dashboardID: GenericID, widgetID: GenericID): Promise<WidgetInfo>;
    /**
     * Get all data or resource list for the current widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param overwrite It can overwrite 'start_date', 'end_date', 'timezone' fields
     */
    getData(dashboardID: GenericID, widgetID: GenericID, params?: GetDataModel): Promise<object>;
    /**
     * Send value of variable for the current widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param data
     * @param bypassBucket
     */
    sendData(dashboardID: GenericID, widgetID: GenericID, data: PostDataModel | PostDataModel[], bypassBucket?: boolean): Promise<object>;
    /**
     * Update value of variable for the current widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param data
     * @param bypassBucket
     */
    editData(dashboardID: GenericID, widgetID: GenericID, data: EditDataModel | EditDataModel[], bypassBucket?: boolean): Promise<object>;
    /**
     * Update value of a resource for the current widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param resourceData Updated data for the resource
     * @param options Additional options
     */
    editResource(dashboardID: GenericID, widgetID: GenericID, resourceData: EditDeviceResource | EditDeviceResource[], options?: EditResourceOptions): Promise<object>;
    /**
     * Run analysis without inserting data to bucket
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param data
     */
    runAnalysis(dashboardID: GenericID, widgetID: GenericID, data: [object | Data]): Promise<object>;
    /**
     * Delete data by it's id, bucket and variable must be associeted with the widget
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     * @param ids
     */
    deleteData(dashboardID: GenericID, widgetID: GenericID, ids: GenericID): Promise<string>;
    /**
     * Generate a new token for the embed widgets
     * It can regenerate the token if call it multi-times
     * @param dashboardID Dashboard identification
     * @param widgetID Widget identification
     */
    tokenGenerate(dashboardID: GenericID, widgetID: GenericID): Promise<{
        widget_token: GenericToken;
    }>;
}
export default Widgets;
//# sourceMappingURL=Dashboard.Widgets.d.ts.map