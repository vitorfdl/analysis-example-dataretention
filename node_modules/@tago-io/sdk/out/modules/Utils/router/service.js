"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class RouterService {
    constructor(service) {
        this.whenList = [];
        this.serviceFunction = service;
    }
    addFunc(func) {
        this.whenList.push(func);
    }
    /**
     * Return true if specific variables are in the scope.
     * Information is available if Analysis is triggered by an widget or action.
     */
    whenVariables(variable) {
        const variable_list = Array.isArray(variable) ? variable : [variable];
        this.addFunc((scope, environment) => !!scope.find((x) => variable_list.includes(x === null || x === void 0 ? void 0 : x.variable)));
        return this;
    }
    /**
     * Return true if variable is included in any variable name in the scope.
     * Information is available if Analysis is triggered by an widget or action.
     */
    whenVariableLike(variable) {
        this.addFunc((scope, environment) => !!scope.find((x) => { var _a; return (_a = x === null || x === void 0 ? void 0 : x.variable) === null || _a === void 0 ? void 0 : _a.includes(variable); }));
        return this;
    }
    /**
     * Return true if value is present for any variable in the scope
     * Information is available if Analysis is triggered by an widget or action.
     */
    whenValues(values) {
        const values_list = Array.isArray(values) ? values : [values];
        this.addFunc((scope, environment) => !!scope.find((x) => values_list.includes(x === null || x === void 0 ? void 0 : x.value)));
        return this;
    }
    /**
     * Return true if serie is present for any variable in the scope
     * Information is available if Analysis is triggered by an widget or action.
     */
    whenSeries(series) {
        const series_list = Array.isArray(series) ? series : [series];
        this.addFunc((scope, environment) => !!scope.find((x) => series_list.includes(x === null || x === void 0 ? void 0 : x.serie)));
        return this;
    }
    /**
     * Return true if input form ID is the same
     * Information is available if Analysis is triggered by an input widget.
     */
    whenInputFormID(id) {
        this.addFunc((scope, environment) => !!scope.find((x) => x.input_form_button_id === id));
        return this;
    }
    /**
     * Return true if a parameter in the scope exists
     * Useful to be used with Device List widget.
     */
    whenParameterExists(parameter) {
        this.addFunc((scope, environment) => !!scope.find((x) => parameter in x));
        return this;
    }
    /**
     * Return true if widget_exec is the same
     * Information is available if Analysis is triggered by an widget.
     */
    whenWidgetExec(widget_exec) {
        this.addFunc((scope, environment) => environment._widget_exec === widget_exec);
        return this;
    }
    /**
     * Return true if action_when is the same
     * Information is available if Analysis is triggered by an action.
     */
    whenActionWhen(action_when) {
        this.addFunc((scope, environment) => environment._action_when === action_when);
        return this;
    }
    /**
     * Return true if action_type is the same
     * Information is available if Analysis is triggered by an action.
     */
    whenActionType(action_type) {
        this.addFunc((scope, environment) => environment._action_type === action_type);
        return this;
    }
    /**
     * Return true if input form ID is the same
     * Information is always available.
     */
    whenEnv(key, value) {
        this.addFunc((scope, environment) => environment[key] === value);
        return this;
    }
    /**
     * Start verifying if all when conditions are true.
     */
    verifyConditionsTrue(scope, environment) {
        for (const func of this.whenList) {
            const result = func(scope, environment);
            if (!result) {
                return false;
            }
        }
        return true;
    }
    /**
     *
     * @param router_params
     * @returns
     */
    runService(router_params) {
        return this.serviceFunction(router_params);
    }
    getServiceName() {
        return this.serviceFunction.name;
    }
}
exports.default = RouterService;
//# sourceMappingURL=service.js.map